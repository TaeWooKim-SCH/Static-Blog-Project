---
title: '[Lv.2] 캐시'
description: '프로그래머스 레벨 2 캐시 문제를 풀어봅시다.'
tags:
  - cache
  - lru
date: 2023-10-22
---

## 문제 설명
지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.<br/>
이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데,
제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.<br/>
어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고,
제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.

어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.


## 입력 형식
- 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.
- cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.
- cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.
- 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.


## 출력 형식
- 입력된 도시이름 배열을 순서대로 처리할 때, "총 실행시간"을 출력한다.


## 풀이
먼저 이 문제를 풀기 위해선 페이지 전환 알고리즘에 대한 이해가 필요하다.

페이지 교체 알고리즘이란 페이징 기법으로 메모리를 관리하는 운영체제에서
페이지 부재가 발생해 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중
어느 것과 교체할지 결정하는 방법이다.

- FIFO: 페이지가 주기억장치에 적재된 시간을 기준으로 교체될 페이지를 선정하는 방법이다.
  - 단점: 중요한 페이지가 오래있었다는 이유로 교체되는 불합리하다.
- LFU: 가장 적은 횟수를 참조하는 페이지를 교체하는 방법이다.
  - 단점: 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 페이지를 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드가 발생할 수 있다.
- LRU: 가장 오랫동안 참조되지 않은 페이지를 교체하는 방법이다.
  - 단점: 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야 하기 때문에 큰 오버헤드가 발생할 수 있다.

### LRU 알고리즘이란
캐시가 사용하는 리소스의 양은 제한되어 있고, 캐시는 제한된 리소스 내에서 데이터를 빠르게 저장하고 접근할 수 있어야 한다.

가장 오랫동안 참조되지 않은 페이지를 교체하는 방법이다.

- 장점
  - 빠른 액세스: 가장 최근에 사용한 아이템부터 가장 적게 사용한 아이템까지 정렬된다. 따라서 아이템에 접근할 경우 O(n)의 시간복잡도를 가진다.
  - 빠른 업데이트: 하나의 아이템에 액세스할 때마다 업데이트 되며, O(n)의 시간복잡도를 가진다.
- 단점
  - 많은 공간 차지
  - n개의 아이템을 저장해야 하는 LRU는 크기가 n인 1개의 Linked-list(queue)와 추적하기 위한 크기가 n인 1개의 hash-map이 필요하다.
  - 이는 O(n)의 시간복잡도를 갖지만, 2개의 데이터 구조를 사용해야 한다는 단점이 있다.

이제 본격적으로 문제 풀이에 들어가보자.

먼저 cacheSize와 cities 배열이 있다.

cache에 대한 배열을 만들어준다. 그 다음 cities의 요소 순서대로 cache에 넣어준다.

cache에 요소를 넣으며 최대 크기는 cacheSize여야 하고, 요소가 들어올때 cache에 이미 요소가 존재한다면 위치를 맨 뒤로 바꿔준다.

만약 이미 cache가 최대 크기라면 가장 오래된 요소를 빼고 새로 들어온 요소를 추가해주며 cacheSize를 유지한다.


## 통과 코드
```js
function solution(cacheSize, cities) {
  const MISS = 5, HIT = 1;
  var answer = 0;
  var cache = [];
  
  if (cacheSize === 0) return MISS * cities.length;
  
  for (var i = 0; i < cities.length; i++) {
    cities[i] = cities[i].toUpperCase();
    var cacheIndex = cache.indexOf(cities[i]);
    if (cacheIndex >= 0) {
      cache.splice(cacheIndex, 1);
      cache.push(cities[i]);
      answer += HIT;
    }
    else {
      if (cache.length === cacheSize) cache.shift();
      cache.push(cities[i]);
      answer += MISS;
    }
  }

  return answer;
}
```